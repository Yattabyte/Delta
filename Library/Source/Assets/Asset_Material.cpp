#include "Assets\Asset_Material.h"
#include "Managers\Config_Manager.h"
#include "Utilities\FileReader.h"

/* -----ASSET TYPE----- */
#define ASSET_TYPE 1

using namespace Asset_Manager;

Asset_Material::~Asset_Material()
{
	if (finalized)
		glDeleteTextures(1, &gl_array_ID);
	if (materialData)
		delete materialData;
}

Asset_Material::Asset_Material()
{
	gl_array_ID = 0; // So we don't bind a texture with an autogenerated int like 3465384972
	handle = 0;
	material_filename = "";
	finalized = false;
}

Asset_Material::Asset_Material(const std::string & _file, const GLuint & mat_buf_ID, const GLuint & spot) : Asset_Material()
{
	material_filename = _file;
	matbuffer_ID = mat_buf_ID;
	mat_spot = spot;
}

Asset_Material::Asset_Material(const std::string(&tx)[MAX_PHYSICAL_IMAGES], const GLuint & mat_buf_ID, const GLuint & spot) : Asset_Material()
{
	for (int x = 0; x < MAX_PHYSICAL_IMAGES; ++x)
		textures[x] = tx[x];
	matbuffer_ID = mat_buf_ID;
	mat_spot = spot;
}

int Asset_Material::GetAssetType()
{
	return ASSET_TYPE;
}

void Asset_Material::Finalize()
{
	shared_lock<shared_mutex> read_guard(m_mutex);
	if (!finalized) {
		read_guard.unlock();
		read_guard.release();
		unique_lock<shared_mutex> write_guard(m_mutex);
		glGenTextures(1, &gl_array_ID);
		glBindTexture(GL_TEXTURE_2D_ARRAY, gl_array_ID);

		float anisotropy, maxAnisotropy;
		anisotropy = CFG::getPreference(CFG_ENUM::C_TEXTURE_ANISOTROPY);
		glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &maxAnisotropy);
		anisotropy = max(0.0f, min(anisotropy, maxAnisotropy));

		glTexStorage3D(GL_TEXTURE_2D_ARRAY, 1, GL_RGBA, (int)size.x, (int)size.y, 3);
		glTexImage3D(GL_TEXTURE_2D_ARRAY, 0, GL_RGBA, (int)size.x, (int)size.y, 3, 0, GL_RGBA, GL_UNSIGNED_BYTE, materialData);
		glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_GENERATE_MIPMAP, GL_TRUE);
		glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
		glTexParameterf(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisotropy);
		glGenerateMipmap(GL_TEXTURE_2D_ARRAY);

		handle = glGetTextureHandleARB(gl_array_ID);
		glMakeTextureHandleResidentARB(handle);
		glBindBuffer(GL_UNIFORM_BUFFER, matbuffer_ID);
		glBufferSubData(GL_UNIFORM_BUFFER, sizeof(GLuint64) * mat_spot, sizeof(GLuint64), &handle);
		glBindBuffer(GL_UNIFORM_BUFFER, 0);
		finalized = true;
	}
}

void Asset_Material::getPBRProperties(const string &filename, string &albedo, string &normal, string &metalness, string &roughness, string &height, string &occlusion)
{
	std::ifstream file_stream(filename);
	for (std::string line; std::getline(file_stream, line); ) {
		if (file_stream.good()) {
			if (line == "PBR") {
				bool end = false;
				std::getline(file_stream, line);

				const size_t propertycount = 6;

				for (int x = 0; x < propertycount; ++x) {
					FileReader::DocParser::Property property;
					std::getline(file_stream, line);
					std::istringstream string_stream(line);
					string_stream >> line;
					if (getProperty(string_stream, property)) {
						if (line == "albedo") albedo = property.s;
						else if (line == "normal") normal = property.s;
						else if (line == "metalness") metalness = property.s;
						else if (line == "roughness") roughness = property.s;
						else if (line == "height") height = property.s;
						else if (line == "occlusion") occlusion = property.s;
						else if (line == "}") break;
						else break;
					}
					else break;
				}
				// ensure we are at end of class
				while (line != "}" && !end) {
					file_stream >> line;
					end = file_stream.bad();
				}
			}
		}
	}
}